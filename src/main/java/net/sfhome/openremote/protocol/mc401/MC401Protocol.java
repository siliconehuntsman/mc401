/**
 * This Java source file was generated by the Gradle 'init' task.
 */
package net.sfhome.openremote.protocol.mc401;

import java.util.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.*;
//import java.util.stream.Collectors.*;

///import javax.persistance.*;

//import JsonFormat.*;



import org.openremote.agent.protocol.*;
import org.openremote.agent.protocol.ProtocolExecutorService;
import org.openremote.model.AbstractValueHolder;
import org.openremote.model.asset.Asset;
import org.openremote.model.asset.AssetType;
import org.openremote.model.asset.AssetAttribute;
import org.openremote.model.asset.AssetDescriptor;
import org.openremote.model.asset.AssetTreeNode;
import org.openremote.model.asset.agent.AgentLink;
import org.openremote.model.asset.agent.ConnectionStatus;
import org.openremote.model.asset.agent.ProtocolConfiguration;


import org.openremote.model.attribute.AttributeEvent;
import org.openremote.model.attribute.AttributeRef;
import org.openremote.model.attribute.AttributeState;
import org.openremote.model.attribute.AttributeValidationResult;
import org.openremote.model.attribute.AttributeValueType;
import org.openremote.model.attribute.MetaItem;
import org.openremote.model.attribute.MetaItemDescriptor;
import org.openremote.model.attribute.MetaItemType;
import org.openremote.model.file.FileInfo;
import org.openremote.model.syslog.SyslogCategory;
import org.openremote.model.ValidationFailure;
import org.openremote.model.ValueHolder;
import org.openremote.model.value.Value;
import org.openremote.model.value.ValueType;
import org.openremote.model.value.Values;
import org.openremote.model.value.*;

import static org.openremote.model.Constants.PROTOCOL_NAMESPACE;
import static org.openremote.model.attribute.MetaItemDescriptor.Access.ACCESS_PRIVATE;
import static org.openremote.model.attribute.MetaItemDescriptorImpl.*;
import static org.openremote.model.util.TextUtil.REGEXP_PATTERN_STRING_NON_EMPTY;
import static org.openremote.model.syslog.SyslogCategory.PROTOCOL;



public class MC401Protocol extends AbstractProtocol implements
    ProtocolLinkedAttributeDiscovery, ProtocolLinkedAttributeImport {
    
    //------------------------------------------------------------------------
    //  Protocol high level properties/methods
    //------------------------------------------------------------------------
    public static final String PROTOCOL_NAME = PROTOCOL_NAMESPACE + ":MC401Protocol";
    public static final String PROTOCOL_DISPLAY_NAME = "MC401";
    public static final String PROTOCOL_VERSION = "1.0";
    public static final int DEFAULT_REQ_INTERVAL_MINS = 5; //Once per day
    public static final int MAX_REQ_INTERVAL_MINS = 43200; //Every 30 day
    public static final int MIN_REQ_INTERVAL_MINS = 60; //Every hour - NOT enforced for testing
    //Default values of Serial port control lines required by simple MC401 Opto Isolator used by author
    //  Please check elcircuit folder for details
    public static final boolean DEFAULT_DTR_USED = true;
    public static final boolean DEFAULT_DTR_VALUE = false;
    public static final boolean DEFAULT_RTS_USED = true;
    public static final boolean DEFAULT_RTS_VALUE = true;

    protected static final Logger LOG = SyslogCategory.getLogger(PROTOCOL, MC401Protocol.class);

  
	@Override
	public String getProtocolName() {
		return PROTOCOL_NAME;
	}
	@Override
	public String getProtocolDisplayName() {
		return PROTOCOL_DISPLAY_NAME;
	}	
	@Override
	public String getVersion() {
		return PROTOCOL_VERSION;
	}
    
    //------------------------------------------------------------------------
    //  Protocol configuration
    //------------------------------------------------------------------------
    
    public static final MetaItemDescriptor META_PROTOCOL_DEVICE_NAME = metaItemString(
            PROTOCOL_NAME + ":DEVname",
            ACCESS_PRIVATE,
            true,
            REGEXP_PATTERN_STRING_NON_EMPTY,
            MetaItemDescriptor.PatternFailure.STRING_EMPTY);
    
    public static final MetaItemDescriptor META_PROTOCOL_DTR_USED = metaItemFixedBoolean(
    		PROTOCOL_NAME + ":DTRused",
    		ACCESS_PRIVATE,
    		true);
	public static final MetaItemDescriptor META_PROTOCOL_DTR_VALUE = metaItemFixedBoolean(
    		PROTOCOL_NAME + ":DTRvalue",
    		ACCESS_PRIVATE,
    		true);
	public static final MetaItemDescriptor META_PROTOCOL_RTS_USED = metaItemFixedBoolean(
    		PROTOCOL_NAME + ":RTSused",
    		ACCESS_PRIVATE,
    		true);
	public static final MetaItemDescriptor META_PROTOCOL_RTS_VALUE = metaItemFixedBoolean(
    		PROTOCOL_NAME + ":RTSvalue",
    		ACCESS_PRIVATE,
    		true);
    public static final  MetaItemDescriptor META_PROTOCOL_REQ1_PERIOD = metaItemInteger(
            PROTOCOL_NAME + ":REQ1period",
    		ACCESS_PRIVATE,
    		true,
            MIN_REQ_INTERVAL_MINS,
            MAX_REQ_INTERVAL_MINS);
    public static final  MetaItemDescriptor META_PROTOCOL_REQ2_PERIOD = metaItemInteger(
            PROTOCOL_NAME + ":REQ2period",
    		ACCESS_PRIVATE,
    		true,
            MIN_REQ_INTERVAL_MINS,
            MAX_REQ_INTERVAL_MINS);
    public static final  MetaItemDescriptor META_PROTOCOL_REQ3_PERIOD = metaItemInteger(
            PROTOCOL_NAME + ":REQ3period",
    		ACCESS_PRIVATE,
    		true,
            MIN_REQ_INTERVAL_MINS,
            MAX_REQ_INTERVAL_MINS);

     
    protected final HashMap<AttributeRef, MC401Port> portMap = new HashMap<>();
    
    /*
    metaItemAny(
            PROTOCOL_NAME + ":RTSvalue",  //String urn
    		ACCESS_PRIVATE,               //Access access
    		true,                         //bolean required
            Value.create(true);           //Value initialValue
            null,                         //String patternRegex
            null,                         //String patternRegexFailure
      */  
    	    	      
 
       
    @Override
    public AssetAttribute getProtocolConfigurationTemplate() {
        LOG.info("Protocol Configuration Template requested");
        return super.getProtocolConfigurationTemplate()
            .addMeta(
                new MetaItem(META_PROTOCOL_DEVICE_NAME, Values.create("/dev/ttyS0")),
                //new MetaItem(META_PROTOCOL_SERIAL_PORT, Values.create("/dev/ttyS0")),
                new MetaItem(META_PROTOCOL_DTR_USED, Values.create(DEFAULT_DTR_USED)),
                new MetaItem(META_PROTOCOL_DTR_VALUE, Values.create(DEFAULT_DTR_VALUE)),
                new MetaItem(META_PROTOCOL_RTS_USED, Values.create(DEFAULT_RTS_USED)),
                new MetaItem(META_PROTOCOL_RTS_VALUE, Values.create(DEFAULT_RTS_VALUE)),
                new MetaItem(META_PROTOCOL_REQ1_PERIOD, Values.create(DEFAULT_REQ_INTERVAL_MINS)),
                new MetaItem(META_PROTOCOL_REQ2_PERIOD, Values.create(DEFAULT_REQ_INTERVAL_MINS)),
                new MetaItem(META_PROTOCOL_REQ3_PERIOD, Values.create(DEFAULT_REQ_INTERVAL_MINS))
            );   
        
    }
    
    public static final List<MetaItemDescriptor> PROTOCOL_META_ITEM_DESCRIPTORS = Arrays.asList(
    		META_PROTOCOL_DEVICE_NAME,
            //META_PROTOCOL_SERIAL_PORT,
            META_PROTOCOL_DTR_USED,
            META_PROTOCOL_DTR_VALUE,
            META_PROTOCOL_RTS_USED,
            META_PROTOCOL_RTS_VALUE,
            META_PROTOCOL_REQ1_PERIOD,
            META_PROTOCOL_REQ2_PERIOD,
            META_PROTOCOL_REQ3_PERIOD
            ); 
    
	@Override
	protected List<MetaItemDescriptor> getProtocolConfigurationMetaItemDescriptors() {
        LOG.info("Producing Protocol Configuration Descriptors");
		return new ArrayList<>(PROTOCOL_META_ITEM_DESCRIPTORS);
	}

    
    @Override
    public AttributeValidationResult validateProtocolConfiguration(AssetAttribute protocolConfiguration) {
        AttributeValidationResult result = super.validateProtocolConfiguration(protocolConfiguration);
        String devName = protocolConfiguration.getMetaItem(META_PROTOCOL_DEVICE_NAME)
            .flatMap(AbstractValueHolder::getValueAsString).orElseThrow(() ->
              new IllegalArgumentException("Missing or invalid required meta item: "+  META_PROTOCOL_DEVICE_NAME));
        
        if(!MC401Port.checkSerialExist(devName)) {

            result.addAttributeFailure(
                        new ValidationFailure(ValueHolder.ValueFailureReason.VALUE_INVALID, String.format("%s does not exist!", devName))
                    ); 
        }
        return result;
    }
    
	@Override
	protected void doLinkProtocolConfiguration(Asset agent, AssetAttribute protocolConfiguration) {
        final AttributeRef protocolRef = protocolConfiguration.getReferenceOrThrow();

        String devName = protocolConfiguration.getMetaItem(META_PROTOCOL_DEVICE_NAME)
            .flatMap(AbstractValueHolder::getValueAsString).orElseThrow(() ->
              new IllegalArgumentException("Missing or invalid required meta item: "+  META_PROTOCOL_DEVICE_NAME));
        
        if(!MC401Port.checkSerialExist(devName)) {
            updateStatus(protocolRef, ConnectionStatus.ERROR_CONFIGURATION);
            LOG.log(Level.SEVERE, "Invalid serial port name for MC401 Protocol: " + devName);  
            return;
        }
           
        Boolean dtrUsed = protocolConfiguration.getMetaItem(META_PROTOCOL_DTR_USED)
            .flatMap(AbstractValueHolder::getValueAsBoolean).orElse(DEFAULT_DTR_USED);
        Boolean dtrValue = protocolConfiguration.getMetaItem(META_PROTOCOL_DTR_VALUE)
            .flatMap(AbstractValueHolder::getValueAsBoolean).orElse(DEFAULT_DTR_VALUE);
        Boolean rtsUsed = protocolConfiguration.getMetaItem(META_PROTOCOL_RTS_USED)
            .flatMap(AbstractValueHolder::getValueAsBoolean).orElse(DEFAULT_RTS_USED);
        Boolean rtsValue = protocolConfiguration.getMetaItem(META_PROTOCOL_RTS_VALUE)
            .flatMap(AbstractValueHolder::getValueAsBoolean).orElse(DEFAULT_RTS_VALUE);
        
        Integer req1Period = protocolConfiguration.getMetaItem(META_PROTOCOL_REQ1_PERIOD)
            .flatMap(AbstractValueHolder::getValueAsInteger).orElse(DEFAULT_REQ_INTERVAL_MINS);
        Integer req2Period = protocolConfiguration.getMetaItem(META_PROTOCOL_REQ2_PERIOD)
            .flatMap(AbstractValueHolder::getValueAsInteger).orElse(DEFAULT_REQ_INTERVAL_MINS);
        Integer req3Period = protocolConfiguration.getMetaItem(META_PROTOCOL_REQ3_PERIOD)
            .flatMap(AbstractValueHolder::getValueAsInteger).orElse(DEFAULT_REQ_INTERVAL_MINS);
        
       
        MC401Port port = new MC401Port(executorService, devName, 
                                       dtrUsed, dtrValue, rtsUsed, rtsValue, 
                                       req1Period, req2Period, req3Period,
                                       (AttributeState state) -> updateLinkedAttribute(state),
                                       (ConnectionStatus status) -> updateStatus(protocolRef, status)
                                      );
             
        port.setLogger(LOG);
        portMap.put(protocolRef, port);
        if(connectPort(protocolConfiguration)) {
           LOG.info("MC401 Protocol connected to serial port: " + devName);  
        }
        
    }
    
    private Boolean connectPort(AssetAttribute protocolConfiguration) {
        final AttributeRef protocolRef = protocolConfiguration.getReferenceOrThrow();
        final MC401Port port = portMap.get(protocolRef);
        

        if(port.initConnection()) {
            //Meter found everything ok
            port.enable();
            updateStatus(protocolRef, ConnectionStatus.CONNECTED);
            LOG.info(String.format("connectPort exec: %s elements: %d, digest: %s elements:%d", 
                   port.isExecutorRunning() ? "Running" : "NO",
                   port.debugGetQueueSize(), 
                   port.isDigestRunning() ? "Running" : "NO", 
                   port.debugGetDigestQueueSize())); 
            return true;
        } else {
            //Meter was not found or interface does not work correctly
            updateStatus(protocolRef, ConnectionStatus.DISCONNECTED);
        }
       
        return false;
        
    }
     
    
    //Load attributes using fields of protocol
    @Override
    public AssetTreeNode[] discoverLinkedAssetAttributes(AssetAttribute protocolConfiguration) {
        final AttributeRef protocolRef = protocolConfiguration.getReferenceOrThrow();
        final MC401Port port = portMap.get(protocolRef);
            
        List<Asset> devices = new ArrayList<>(1);
        List<AssetAttribute> attributes = new ArrayList<>(3);
        
        LOG.info("Asset meter creation started");
        
        Asset meter = new Asset("Heat Meter", AssetType.THING);
        MetaItem agentLink = AgentLink.asAgentLinkMetaItem(protocolConfiguration.getReferenceOrThrow());
        meter.setAttributes(port.getAssetAttributeTemplate(1, META_ATTRIBUTE_FIELD_NAME).stream()
                            .map(attr -> attr.addMeta(agentLink))
                            .collect(Collectors.toList()));
    
        LOG.info("Asset meter created");
        devices.add(meter);
        
        return devices.stream().map(AssetTreeNode::new).toArray(AssetTreeNode[]::new);
	}
    
    //Created to workaround OpenRemote behavior of not operational asset selector with only interface ProtocolLinkedAttributeDiscovery           
    @Override
    public AssetTreeNode[] discoverLinkedAssetAttributes(AssetAttribute protocolConfiguration, FileInfo fileInfo) throws IllegalStateException {
        return new AssetTreeNode[0];
        }
          
    
	@Override
	protected void doUnlinkProtocolConfiguration(Asset agent, AssetAttribute protocolConfiguration) {
		// TODO Auto-generated method stub
        final AttributeRef protocolRef = protocolConfiguration.getReferenceOrThrow();
        final MC401Port port = portMap.get(protocolRef);
        
        port.disable();
        portMap.remove(protocolRef);
		LOG.info("Protocol Configuration unlinked: " + ProtocolConfiguration.getProtocolName(protocolConfiguration));
	}
    
    //--------------------------------------------------------------------------------------------
    //Attribute methods
    //--------------------------------------------------------------------------------------------
    public static final MetaItemDescriptor META_ATTRIBUTE_FIELD_NAME = metaItemString(
            PROTOCOL_NAME + ":fieldName",
            ACCESS_PRIVATE,
            true,
            REGEXP_PATTERN_STRING_NON_EMPTY,
            MetaItemDescriptor.PatternFailure.STRING_EMPTY);
    
    public static final List<MetaItemDescriptor> ATTRIBUTE_META_ITEM_DESCRIPTORS = Arrays.asList(
    		META_ATTRIBUTE_FIELD_NAME            
            ); 
    
    @Override
	protected List<MetaItemDescriptor> getLinkedAttributeMetaItemDescriptors() {
		// return new ArrayList<>(ATTRIBUTE_META_ITEM_DESCRIPTORS);
        LOG.info("Producing Linked Attribute Descriptors");
		return new ArrayList<>(ATTRIBUTE_META_ITEM_DESCRIPTORS);
	}
    
	@Override
	protected void doLinkAttribute(AssetAttribute attribute, AssetAttribute protocolConfiguration) {
		final AttributeRef attributeRef = attribute.getReferenceOrThrow();
        final AttributeRef protocolRef = protocolConfiguration.getReferenceOrThrow();
        final MC401Port port = portMap.get(protocolRef);
        
        String protocolName = protocolConfiguration.getName().orElse("NAME NOT GIVEN") ;
/*            MetaItem(META_PROTOCOL_DEVICE_NAME)
            .flatMap(AbstractValueHolder::getValueAsString).orElseThrow(() ->
              new IllegalArgumentException("Missing or invalid required meta item: "+  META_PROTOCOL_DEVICE_NAME));
*/
        String fieldName = attribute.getMetaItem(META_ATTRIBUTE_FIELD_NAME)
            .flatMap(AbstractValueHolder::getValueAsString).orElseThrow(() ->
              new IllegalArgumentException("Missing or invalid required meta item: "+  META_ATTRIBUTE_FIELD_NAME));
        
        LOG.info(String.format("MC401 Linking Attribute: %s field: %s for protocol: %s", attribute.getLabel().orElse(""), fieldName, protocolName));
        
        port.linkAttribute(attributeRef, fieldName);

	}
	@Override
	protected void doUnlinkAttribute(AssetAttribute attribute, AssetAttribute protocolConfiguration) {
		
        final AttributeRef attributeRef = attribute.getReferenceOrThrow();
        final AttributeRef protocolRef = protocolConfiguration.getReferenceOrThrow();
        final MC401Port port = portMap.get(protocolRef);
                
        Optional<StringValue> fieldName = Values.getMetaItemValueOrThrow(
                attribute,
                META_ATTRIBUTE_FIELD_NAME,
                true,
                true);
        
        fieldName.ifPresent(name -> port.unLinkAttribute(attributeRef, name.getString()));
        
		LOG.info("Attribute unlinked: " + attribute.getName().orElse("NAME NOT GIVEN") + 
                 " for field: " + fieldName.orElseGet(() -> Values.create("field name missing")).getString() + 
                 " from protocol: " + ProtocolConfiguration.getProtocolName(protocolConfiguration)
                );
	}
    @Override
	protected void processLinkedAttributeWrite(AttributeEvent event, Value processedValue,
			AssetAttribute protocolConfiguration) {
		// TODO Auto-generated method stub
		LOG.info("LinkAttribute value: " + processedValue.toString() + 
                 " write: " + event.getAttributeName() + 
                 " from protocol: " + ProtocolConfiguration.getProtocolName(protocolConfiguration)
                );
	}  
    
}
