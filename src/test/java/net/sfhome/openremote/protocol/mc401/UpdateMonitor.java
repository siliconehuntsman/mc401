/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package net.sfhome.openremote.protocol.mc401.TestUtils;

import com.google.gwt.regexp.shared.RegExp;
//import org.gwtproject.regexp.shared.RegExp;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import static org.junit.jupiter.api.Assertions.*;

import java.lang.Exception;
import java.util.AbstractMap.SimpleEntry;
import java.util.Collections;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.*;
import java.util.stream.*;
import java.util.stream.Collectors.*;


//import org.junit.Test;
//port org.junit.BeforeEach;

//import static org.junit.Assert.*;


import net.sfhome.openremote.protocol.mc401.*;

import org.openremote.model.attribute.AttributeRef;
import org.openremote.model.attribute.AttributeState;
import org.openremote.model.value.*;

/**
 * <p> UpdateMonitor emulates OpenRemote server,
 *     It creates set of attributes that can be linked to RequestResponses
 *     It receives attribute update requests from RequestResponses
 *     It records number of update requests</p>
 */
public class UpdateMonitor implements Consumer<AttributeState>  { //BiConsumer <AttributeRef, Value> {
    final private String[] req1Fields = ResponseFields.getResponseFields(1);
    final private String[] req2Fields = ResponseFields.getResponseFields(2);
    final private String[] req3Fields = ResponseFields.getResponseFields(3);

    //attributeList stores list off all attributes, each entry is a map composed of the following fiels:
    //attrRef - reference to AttributeRef object of OpenRemote Server
    //fieldName - response field name
    //requestNumber - number of request (code in the request
    //value - value of the attribute being result of update
    final private List<HashMap<String, Object>> attributeList = new ArrayList<>();

    //Map storing list of all fields along with event counter indicating:
    // fieldCountUse - how many times given field was registered as attribute
    // fieldCountUpdates - how many times given field has been updated
    // requestNumber - request number in which field can be found
    final private TreeMap<String, HashMap<String,  Integer>> regFieldCount = new TreeMap<>();
    //              ^Field name  |  ^Count type | ^Count value

    /**
     * ScoreBoard recording all values of all attributes
     * It can be null when not used.
     */
    Optional<ScoreBoard> scoreBoard = Optional.empty();

    long updateCount;
    long updateHits;

    static String ValueToString(Value value) {
        String returnValue;        

        switch(value.getType()) {
            case STRING : returnValue = ((StringValue) value).getString(); break;
            case NUMBER : returnValue = ((NumberValue) value).asString(); break;
            case BOOLEAN :    returnValue = ((BooleanValue) value).getBoolean() ? "TRUE" : "FALSE"; break;
            default : returnValue = "UNSUPPORTED TYPE"; break;                
        }
        return returnValue;        

    }

    /**
     * <p> Creator to single request and fixed number of attributes. </p>
     *   @param size - number of attributes 
     *   @param reqNumber - number of request/response
     */

    public UpdateMonitor(Integer size, Integer reqNumber) {
        scoreBoard = Optional.empty();
        if(reqNumber > 3 || reqNumber < 1)
            reqNumber = 1;
        try {
            buildAttrList(size, reqNumber);
        } 
        catch(Exception exp) {
            System.out.printf("Exception caught: %s\n", exp.getMessage()); 

        }
    }

    /**
     * <p> Creator for random number of attributes in each of three requests. </p>
     *   @param sizeRange - range of sizes to randomize number of attributes for 1st, 2nd and 3rd request
     */

    public UpdateMonitor(int sizeRange) {
        Random sizeGen = new Random(); 
        
        try {
            buildAttrList(sizeGen.nextInt(sizeRange), 1);
            buildAttrList(sizeGen.nextInt(sizeRange), 2);
            buildAttrList(sizeGen.nextInt(sizeRange), 3);
        } 
        catch(Exception exp) {
            System.out.printf("Exception caught in buildAttrList: %s\n", exp.getMessage()); 

        }
    }

    public void registerScoreBoard(ScoreBoard sc) {
        assertNotNull(sc, "If UpdateMonitor.registerScoreBoard method is called the ScoreBoard argument cannot be NULL");
        scoreBoard = Optional.of(sc);

    }
    /**
     *  <p> Method builds attributes list, field names and attribute id is randomized</p>
     *   @param size - number of attributes to be created
     *   @param reqNumber - number of request for which response we should create attributes
     */
    private void buildAttrList(int size, int reqNumber) throws IllegalArgumentException, Exception {
        if(reqNumber < 1 || reqNumber > 3) {
            throw new IllegalArgumentException(String.format("reqNumber argument in UpdateMonitor creator needs to have value <1,3>, while is has value of %d\n", reqNumber)); 
        }
        String[] fieldNames = reqNumber == 3 ? req3Fields :
                              reqNumber == 2 ? req2Fields :
                                               req1Fields;

        Random fieldGen = new Random();
        Random eIdGen = new Random();


        Integer fieldSelection;
        Integer entityId;

        //Initilize counter table for all fields of response for given request number
        initilizeFieldCounters(reqNumber);

        for(Integer i = 0; i < size; i++) {
            HashMap<String, Object> entry = new HashMap<>();
            //attributeRef creator requires two argument entityId and attributeName
            //for testing purpose we select that attributeIf is just simple integer value and attributeName is response field name

            //select field by randomizing its number
            fieldSelection = fieldGen.nextInt(fieldNames.length);
            //generate reference number to entity as if on OpenRemote server
            entityId = (int) Math.round(eIdGen.nextDouble() * 10000);

            //compose entry that links together AttributeRef, randomized field name, request number and initial value of attribute
            entry.put("attrRef", new AttributeRef(entityId.toString(), fieldNames[fieldSelection]));
            entry.put("fieldName", fieldNames[fieldSelection]);
            entry.put("requestNumber", reqNumber);
            //Set initial value of attribute to 0  
            entry.put("value", Values.create((double) 0));

            //Store entry in the list
            attributeList.add(entry);

            //Prepare record storing nuber of 
            HashMap<String, Integer> countRecord;
            //Record which fields and how many times where added
            if((countRecord = regFieldCount.get(fieldNames[fieldSelection])) != null) {
                countRecord.put("fieldCountUse", countRecord.get("fieldCountUse")+1); 
                regFieldCount.put(fieldNames[fieldSelection], countRecord);
            } else {
                throw new Exception(String.format("fieldCount record not found in UpdateMonitor creator, fieldSelection= %d while max is %d\n", 
                                              fieldSelection, 
                                              fieldNames.length));                                                  
            }

        }  
        updateCount = 0; 
        updateHits = 0;

    }

    /**
     * <p> Initilizes counter table for all fields of response for given request number </p>
     *  @param reqNumber - number of request for which response field counters should be initilized
     */
    private void initilizeFieldCounters(int reqNumber) throws IllegalArgumentException {

        if(reqNumber < 1 || reqNumber > 3) {
            throw new IllegalArgumentException(String.format("reqNumber argument in initilizeFieldCounters needs to have value <1,3>, while is has value of %d\n", reqNumber)); 
        }

        //Get array with field names of selected response
        HashMap<String, Integer> countRecord;
        String[] fieldNames = reqNumber == 3 ? req3Fields :
                              reqNumber == 2 ? req2Fields :
                                               req1Fields;


        //Initilize counters
        //   fieldCountUse - how many times given field was linked to attribute
        //   fieldCountUse - how many times given field was "updated", actually how many times there was received and linked attributes were requested to be updated
        //   requestNumber - stores tp which response type field belongs
        for(int x=0; x < fieldNames.length; x++) {
            countRecord = new HashMap<String, Integer>();
            countRecord.put("fieldCountUse", 0); 
            countRecord.put("fieldCountUpdates", 0); 
            countRecord.put("requestNumber", reqNumber);
            regFieldCount.put(fieldNames[x], countRecord);

        }
    }



    /**  
     * <p> Method to get stream of attributes records, required to link attributes with the Protocol as in OR server </p>
     * @return Returns stream of attribute entries
     * @since 1.0
    */
    public Stream<HashMap<String, Object>> attributesAsStream() {
      return attributeList == null || attributeList.isEmpty() ? Stream.empty() : 
        attributeList.stream()
            .map(entry -> new HashMap<String, Object>(entry));
    }

    /**
     * Consumer function implementation to be used to receive update requests for given attribute ref
     * @param attrRef - attribute reference (@see org.openremote.model.attribute.AttributeRef) 
     * to the attribute that shall be updated
     * @param newValue - a value that shall be written to attribute
     */
    public void accept(AttributeState state) {
        AttributeRef attrRef = state.getAttributeRef();
        Value newValue = state.getValue().orElseThrow(IllegalArgumentException::new);
       
        //System.out.println("Processing attribute update");
        updateCount++;  //increment simple counter of calls

        for(Map<String, Object> entry : attributeList) {
            if(entry.get("attrRef").equals(attrRef)) {
                String entityId = ((AttributeRef) entry.get("attrRef")).getEntityId(); 
                String attrName = ((AttributeRef) entry.get("attrRef")).getAttributeName();
                String oldValue = ValueToString((Value) entry.get("value"));
                String newStringValue = ValueToString(newValue);
           /*     System.out.printf("Updating field: %20s in entity: %10s value: %10s to new value of: %10s\n", 
                                  attrName, entityId,                                      
                                  oldValue,
                                  newStringValue);
                                  */
                entry.put("value", newValue);

                HashMap<String, Integer> countRecord;
                if((countRecord = regFieldCount.get(attrName)) != null) {
                    countRecord.put("fieldCountUpdates", countRecord.get("fieldCountUpdates")+1); 
                    regFieldCount.put(attrName, countRecord);
                    updateHits++; //increment global counter  of matched attributes, mismatch in counters will trigger error
                }
                //Use scoreBoard if registered to record given update with attrName and newStringValue
                scoreBoard.ifPresent(sc -> sc.addAtributeValue(entityId, attrName, newStringValue));

            }
        }

    }

    public long getUpdateHits() {
        return updateHits;
    }

    public long getUpdateCount() {
        return updateCount;
    }

    /**
     * Method to get a final raport about all fields and updates
     * @param numValidReq1 - number of valid requests or rather responses received for request number 1
     * @param numValidReq2 - number of valid requests or rather responses received for request number 2
     * @param numValidReq3 - number of valid requests or rather responses received for request number 3
     * @return string containing the report
     */
    public String getSummary(Integer numValidReq1, Integer numValidReq2, Integer numValidReq3) {
        String summary = "";
        int[] numValidReq = { numValidReq1, numValidReq2, numValidReq3};

        Set<Map.Entry<String, HashMap<String,  Integer>>> fields = regFieldCount.entrySet();
        summary = String.format("Request number 1:\n");
      /*  summary = fields.stream()
                .filter(entry -> {
                    HashMap<String,  Integer> countRecord = entry.getValue();
                    int reqNumber = countRecord.get("requestNumber");
                    return reqNumber == 1;
                }) 
                .map(entry -> {
                    String fieldName = entry.getKey();
                    HashMap<String,  Integer> countRecord = entry.getValue();
                    int fieldCountUse = countRecord.get("fieldCountUse");
                    int fieldCountUpdates = countRecord.get("fieldCountUpdates");
                    //add printf to stream
                    return String.format(" - Field: %20s, Registered: %5d, Updated: %5d", fieldName, fieldCountUse, fieldCountUpdates);
                    //return line;
            })
            .collect(Collectors.joining("\n", "Request number 1:\n", "\n--------------"));
           // .forEach(System::out::println);
           */
        //System.out.println(fields);
        Map<Integer, String> summaryByRequest = fields.stream()
                      .collect(Collectors.groupingBy(entry -> {
                                     HashMap<String,  Integer> countRecord = entry.getValue();
                                     Integer reqNumber = countRecord.get("requestNumber");
                                     return reqNumber;
                                 }, 
                                 Collectors.mapping(item -> {
                                            Map.Entry<String, HashMap<String,  Integer>> entry = (Map.Entry<String, HashMap<String,  Integer>>) item;
                                            String fieldName = entry.getKey();
                                            HashMap<String,  Integer> countRecord = entry.getValue();
                                            int fieldCountUse = countRecord.get("fieldCountUse");
                                            int fieldCountUpdates = countRecord.get("fieldCountUpdates");
                                            int reqNumber = countRecord.get("requestNumber");
                                            //add printf to stream
//                                               assertTrue(fieldCountUse * numValidReq[reqNumber - 1] == fieldCountUpdates, "Incorrect number of updates of field");
                                            return String.format(" - Field: %20s, Registered: %5d, Updated: %5d - %s", fieldName, fieldCountUse, fieldCountUpdates, (fieldCountUse * numValidReq[reqNumber-1] == fieldCountUpdates) ? "OK" : "ERROR");                        
                                      }, 
                                      Collectors.joining("\n"))));
       // System.out.println(summaryByRequest);
        Set<Map.Entry<Integer, String>> setByRequest = summaryByRequest.entrySet();
        summary = setByRequest.stream().map(entry -> {
                                    return String.format("Request number: %d valid responses received: %d\n%s", entry.getKey(), numValidReq[entry.getKey()-1], entry.getValue());   
                                 })
                                 .collect(Collectors.joining("\n"));
        return summary;
    }
    
    public double getCoverage() {
        Set<Map.Entry<String, HashMap<String,  Integer>>> fields = regFieldCount.entrySet();
        Map<Integer, Double> summaryByRequest = fields.stream()
                      .collect(Collectors.groupingBy(entry -> {
                                     HashMap<String,  Integer> countRecord = entry.getValue();
                                     Integer reqNumber = countRecord.get("requestNumber");
                                     return reqNumber;
                                 }, 
                                 Collectors.averagingInt(item -> {
                                            Map.Entry<String, HashMap<String,  Integer>> entry = (Map.Entry<String, HashMap<String,  Integer>>) item;
                                            String fieldName = entry.getKey();
                                            HashMap<String,  Integer> countRecord = entry.getValue();
                                            return countRecord.get("fieldCountUse") > 0 ? 1 : 0;
                       
                                      })));
       // System.out.println(summaryByRequest);
        Set<Map.Entry<Integer, Double>> setByRequest = summaryByRequest.entrySet();
        
        System.out.println(String.format("Coverage summary per request:"));
        System.out.println(summaryByRequest);
       
        
        setByRequest.stream()
            .forEach(entry -> {
                 Double average = entry.getValue(); ///ResponseFields.getResponseFields(entry.getKey()) *100;
                 System.out.println(String.format("Request number: %d coverage: %.2g%%", entry.getKey(), average*100));   
            });

        Double coverTotal = setByRequest.stream()
            .collect(Collectors.averagingDouble(entry -> {
                 Double average = entry.getValue(); ///ResponseFields.getResponseFields(entry.getKey()) *100;
                 return average;
            }));
            
        coverTotal *= 100;
        System.out.println(String.format("Total coverage: %.2g%%", coverTotal));
        return coverTotal;                         
    }
    /**
     * Method to get a final raport about all fields and updates
     * @param numValidReq1 - number of valid requests or rather responses received for request number 1
     * @param numValidReq2 - number of valid requests or rather responses received for request number 2
     * @param numValidReq3 - number of valid requests or rather responses received for request number 3
     * @return string containing the report
     */
 /*   public String getSummaryError(Integer numValidReq1, Integer numValidReq2, Integer numValidReq3) {
        String summary = "";
        int[] numValidReq = { numValidReq1, numValidReq2, numValidReq3};

        Set<Map.Entry<String, HashMap<String,  Integer>>> fields = regFieldCount.entrySet();
        summary = String.format("Request number 1:\n");

        Map<Integer, String> summaryByRequest = fields.stream()
                      .collect(Collectors.groupingBy(entry -> {
                                     HashMap<String,  Integer> countRecord = entry.getValue();
                                     Integer reqNumber = countRecord.get("requestNumber");
                                     return reqNumber;
                                 }, 
                                 Collectors.mapping(item -> {
                                            Map.Entry<String, HashMap<String,  Integer>> entry = (Map.Entry<String, HashMap<String,  Integer>>) item;
                                            String fieldName = entry.getKey();
                                            HashMap<String,  Integer> countRecord = entry.getValue();
                                            int fieldCountUse = countRecord.get("fieldCountUse");
                                            int fieldCountUpdates = countRecord.get("fieldCountUpdates");
                                            int reqNumber = countRecord.get("requestNumber");
                                            //add printf to stream
//                                               assertTrue(fieldCountUse * numValidReq[reqNumber - 1] == fieldCountUpdates, "Incorrect number of updates of field");
                                            return (fieldCountUse * numValidReq[reqNumber-1] == fieldCountUpdates;                        
                                      }, 
                                      Collectors.joining("\n"))));
       // System.out.println(summaryByRequest);
        Set<Map.Entry<Integer, String>> setByRequest = summaryByRequest.entrySet();
        summary = setByRequest.stream().map(entry -> {
                                    return String.format("Request number: %d valid responses received: %d\n%s", entry.getKey(), numValidReq[entry.getKey()-1], entry.getValue());   
                                 })
                                 .collect(Collectors.joining("\n"));
        return summary;
    }
*/
}
