/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package net.sfhome.openremote.protocol.mc401;


import com.google.gwt.regexp.shared.RegExp;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import static org.junit.jupiter.api.Assertions.*;

import java.lang.Exception;
import java.lang.System;
import java.util.AbstractMap.SimpleEntry;
import java.util.Collections;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.*;
import java.util.stream.*;
import java.util.stream.Collectors.*;


import net.sfhome.openremote.protocol.mc401.*;
import net.sfhome.openremote.protocol.mc401.TestUtils.*;

import org.openremote.model.attribute.AttributeRef;
import org.openremote.model.attribute.AttributeState;
import org.openremote.model.value.*;


public class ResponseRequestTests {
    
    @BeforeEach
    void init() {
        //System.out.printf("Executing test...");
        
        //It is required to avoid NullPointerException during isolated tests of ResponseRequest class
        System.setProperty("MJX_IsolationTestMode", "true");
    }
    
    // ***************************************************************************************************************
    //   TESTS
    // ***************************************************************************************************************
    
    @Test public void testFindRespNum() {
        
        int respNumber = ResponseFields.findResponseNumber("ReadingDay");
        assertTrue(respNumber == 3, String.format("ReadingDay should be found in response 3, but was repoerted in %d", respNumber));
        
        respNumber = ResponseFields.findResponseNumber("CustNo2");
        assertTrue(respNumber == 2, String.format("CustNo2 should be found in response 2, but was repoerted in %d", respNumber));
        
        respNumber = ResponseFields.findResponseNumber("TeleRead");
        assertTrue(respNumber == 0, String.format("TeleRead should not be found, but was found in %d", respNumber));
    }
               
     @Test public void testSystemProperties() {
        assertEquals(System.getProperty("MJX_IsolationTestMode"), "true", "MJX_IsolationTestMode not equal");
         System.out.println("MJX_IsolationTestMode= " + System.getProperty("MJX_IsolationTestMode"));
     }
    
    /**
     *
     */
    
    @Test 
 //   @EnabledIfSystemProperty(named = "MJX_IsolationTestMode", matches = "true")
    public void testSimpleResponseProc() {
        int updateCount = 0;
        Integer req1Period = 60; 
        UpdateMonitor monitor = new UpdateMonitor(10, 1);
        
        AbstractResponseRequest processor = new ResponseRequest(1, req1Period, monitor);
        monitor.attributesAsStream()
            .forEach(entry -> processor.linkAttribute((AttributeRef) entry.get("attrRef"), (String) entry.get("fieldName") ));

        processor.peepRegedAttr();

        String response = new String("0000001 0000002 0027084 0002208 0002231 0000006 0000007 0000008 0000009 0000028 \r");
        processor.accept(response);
        
        response = "0001122 0003344 0025566 0006677 0007788 0009996 0034257 0005653 0078909 0007654 \r";
        processor.accept(response);
        
        System.out.println(monitor.getSummary(2,0,0));
        //assertTrue(monitor.getUpdateCount() == monitor.getUpdateHits(), "Number of update count differs from update hits. There are orphanated attributes" );
        
            
    }
    
    /**
     *
     */
    @Test public void testResponseProc() {
        int updateCount = 0;
        Integer reqPeriod = 60; 
        UpdateMonitor monitor = new UpdateMonitor(20);
        ScoreBoard scoreBoard = new ScoreBoard();
        ResponseGenerator responseGenerator = new ResponseGenerator(scoreBoard, true);
        
        monitor.registerScoreBoard(scoreBoard);
        
        AbstractResponseRequest processorReq1 = new ResponseRequest(1, reqPeriod, monitor);
        AbstractResponseRequest processorReq2 = new ResponseRequest(2, reqPeriod, monitor);
        AbstractResponseRequest processorReq3 = new ResponseRequest(3, reqPeriod, monitor);
        monitor.attributesAsStream()
            .forEach(entry -> {
                    int reqNumber = (int) entry.get("requestNumber");
                    AbstractResponseRequest processor = reqNumber == 3 ? processorReq3 :
                                                        reqNumber == 2 ? processorReq2 :
                                                                         processorReq1;
                    processor.linkAttribute((AttributeRef) entry.get("attrRef"), (String) entry.get("fieldName"));
                 }
             ); 
        processorReq1.peepRegedAttr();
        
        
        AbstractResponseRequest processor = null;
        SimpleEntry<Integer, String> response;
        
        for(int x=0; x<10;x++) {
            System.out.println(String.format("Generating response number: %d", x));            
            response = responseGenerator.getNext();
            System.out.println(String.format("Response generated for request#: %d - %s", response.getKey(), response.getValue()));
            //Add customer number if needed
            switch(response.getKey()) {
                case 1:
                    processor = processorReq1;
                    break;
                case 2:
                    processor = processorReq2;
                    break;                    
                case 3:
                    processor = processorReq3;
                    break;           
            }
            //System.out.println("Request " + Integer.toString(reqNum) + " : " + response);
            //Send response for processing
            
            System.out.println("Sending response for processing...");
            processor.accept(response.getValue());
            
        }

        int[] reqCounter = responseGenerator.getResponseCounters();
        
        System.out.println(monitor.getSummary(reqCounter[0], reqCounter[1], reqCounter[2]));
        monitor.getCoverage();
        System.out.println(String.format("Monitor update count: %d", (long)monitor.getUpdateCount()));
        System.out.println(String.format("Monitor update hits: %d", (long)monitor.getUpdateHits()));
        assertTrue(monitor.getUpdateCount() == monitor.getUpdateHits(), 
                   String.format("Number of update count (%d) differs from update hits (%d) - %s. ", 
                                 monitor.getUpdateCount(), 
                                 monitor.getUpdateHits(), 
                                 monitor.getUpdateCount() == monitor.getUpdateHits() ? "TRUE" : "FALSE") );    
        assertTrue(scoreBoard.getErrorCounter() == 0, String.format("Scoreboard found %d errors!!", scoreBoard.getErrorCounter()));
    }
    
    @Test public void testMessageEnable() throws InterruptedException {
               
        int error = 0;
        Integer reqPeriod = 1;
        int count = 0;
        
        
        System.setProperty("MJX_IsolationTestMode", "false");
        LinkedBlockingQueue<QueueMessage> queue = new LinkedBlockingQueue<>();
        ScheduledThreadPoolExecutor executor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1);
        executor.setRemoveOnCancelPolicy(true);
                
        //Create set of 10 attributes for request# 1
        UpdateMonitor monitor = new UpdateMonitor(1, 1);
        
        AbstractResponseRequest processor = new ResponseRequest(1, reqPeriod, monitor);
        processor.installQueueServices(executor, queue);
        
        Thread.sleep(2* reqPeriod * 1000);
        count = queue.size();
        System.out.println(String.format("Queue size: %d", count));
        assertEquals(count, 0, "Queue should be empty without registered attributes!");
  
        monitor.attributesAsStream()
            .forEach(entry -> processor.linkAttribute((AttributeRef) entry.get("attrRef"), (String) entry.get("fieldName") )); 
        processor.peepRegedAttr();

       
        count = 0;
        for(int i=0; i<30;i++) {
            count = queue.size();
            System.out.println(String.format("%d s - queue size: %d", i, count));
            Thread.sleep(200);
            
        }
        assertEquals(count, 5, "Invalid number of messages loaded to the queue");
        System.out.println("Finished!");       
        
    }
    
            
                     
                     
    @Test public void testSchedulePeriod() throws InterruptedException {
               
        int error = 0;
        Integer reqPeriod = 1;
        int count = 0;
        
        
        System.setProperty("MJX_IsolationTestMode", "false");
        LinkedBlockingQueue<QueueMessage> queue = new LinkedBlockingQueue<>();
        ScheduledThreadPoolExecutor executor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1);
        executor.setRemoveOnCancelPolicy(true);
                
        //Create set of 10 attributes for request# 1
        UpdateMonitor monitor = new UpdateMonitor(10, 1);
        
        AbstractResponseRequest processor = new ResponseRequest(1, reqPeriod, monitor);
        processor.installQueueServices(executor, queue);
                              
        
        monitor.attributesAsStream()
            .forEach(entry -> processor.linkAttribute((AttributeRef) entry.get("attrRef"), (String) entry.get("fieldName") )); 
        processor.peepRegedAttr();

        count = 0;
        for(int i=0; i<30;i++) {
            count = queue.size();
            System.out.println(String.format("%d s - queue size: %d", i, count));
            Thread.sleep(200);
            
        }
        assertEquals(count, 5, "Invalid number of messages loaded to the queue");
        System.out.println("Finished!");       
        
    }                   
                     
                     
                     
    @Test public void testScheduleTerminated() throws InterruptedException {
               
        int error = 0;
        Integer reqPeriod = 1;
        int count = 0;
        
        
        System.setProperty("MJX_IsolationTestMode", "false");
        LinkedBlockingQueue<QueueMessage> queue = new LinkedBlockingQueue<>();
        ScheduledThreadPoolExecutor executor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1);
        executor.setRemoveOnCancelPolicy(true);
                
        //Create set of 10 attributes for request# 1
        UpdateMonitor monitor = new UpdateMonitor(10, 1);
        
        AbstractResponseRequest processor = new ResponseRequest(1, reqPeriod, monitor);
        processor.installQueueServices(executor, queue);
                              
        
        monitor.attributesAsStream()
            .forEach(entry -> processor.linkAttribute((AttributeRef) entry.get("attrRef"), (String) entry.get("fieldName") )); 
        processor.peepRegedAttr();


        count = 0;
        for(int i=0; i<15;i++) {
            count = queue.size();
            System.out.println(String.format("%d s - queue size: %d", i, count));
            Thread.sleep(200);            
        }
        assertEquals(count, 2, "Invalid number of messages loaded to the queue");
        
        System.out.println("Clearing queue");
        queue.clear();
        assertEquals(queue.size(), 0, "Queue should be empty!");
        
        monitor.attributesAsStream()
            .forEach(entry -> {
                    processor.unlinkAttribute((AttributeRef) entry.get("attrRef"), (String) entry.get("fieldName") );

                    int localCnt = queue.size();
                    System.out.println(String.format("Attribute removed, queue size: %d", localCnt));
                    try {
                      Thread.sleep(500); 
                    } 
                    catch (InterruptedException exp) {
                      System.out.println("Thread interrupted while waiting!");                    
                    }
                }      
            ); 
        count = queue.size();
        System.out.println(String.format("Queue size: %d", count));
        assertEquals(count, 4, "Invalid number of messages loaded to the queue");
        System.out.println("Waiting two times longer that message generation period...");
        Thread.sleep(2 * reqPeriod * 1000); 
        
        System.out.println("Checking if number of elements in the queue has increased after extra waiting time");
        System.out.println(String.format("Queue size: %d", queue.size()));
        assertEquals(count, queue.size(), "Number of messages in the queue should not change after unlinking all attribute!");
        
        System.out.println("Finished!");       
        
    }
    
    
    
    @Test public void testScheduleRequest() throws InterruptedException {
               
        int error = 0;
        Integer reqPeriod = 1;
        int count = 0;
        
        
        System.setProperty("MJX_IsolationTestMode", "false");
        LinkedBlockingQueue<QueueMessage> queue = new LinkedBlockingQueue<>();
        ScheduledThreadPoolExecutor executor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1);
        executor.setRemoveOnCancelPolicy(true);
                
        //Create set of 10 attributes for request# 1
        UpdateMonitor monitor = new UpdateMonitor(10, 1);
        
        AbstractResponseRequest processor = new ResponseRequest(1, reqPeriod, monitor);
        processor.installQueueServices(executor, queue);
                              
        
        monitor.attributesAsStream()
            .forEach(entry -> processor.linkAttribute((AttributeRef) entry.get("attrRef"), (String) entry.get("fieldName") )); 
        processor.peepRegedAttr();

        
        
        String response = new String("0000001 0000002 0027084 0002208 0002231 0000006 0000007 0000008 0000009 0000028 \r");
        processor.accept(response);
        
       
        QueueMessage message;
        System.out.println("Wait for record in the queue");
            
        message = queue.poll(10, TimeUnit.SECONDS);
        assertNotNull(message, "There should be element available in the queue, but queue is still empty!");
        
        byte[] req;
        req = message.getRequest();
        System.out.println(String.format("%c, %c, %d", req[0], req[1], req[2]));
            
        System.out.println(String.format("Expected response length: %d", message.getResponseLength()));
        System.out.println(message.getClass().getName());
        
        
        System.out.println("Finished!");       
        
    }

     /**
     *
     */
    @Test public void testQueue() throws InterruptedException{
        int updateCount = 0;
        Integer reqPeriod = 1; 
        UpdateMonitor monitor = new UpdateMonitor(20);
        ScoreBoard scoreBoard = new ScoreBoard();
        ResponseGenerator responseGenerator = new ResponseGenerator(scoreBoard, true);
        
        System.setProperty("MJX_IsolationTestMode", "false");
        LinkedBlockingQueue<QueueMessage> queue = new LinkedBlockingQueue<>();
        ScheduledThreadPoolExecutor executor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1);
        executor.setRemoveOnCancelPolicy(true);
        
        
        
        monitor.registerScoreBoard(scoreBoard);
        
        AbstractResponseRequest processorReq1 = new ResponseRequest(1, reqPeriod, monitor);
        AbstractResponseRequest processorReq2 = new ResponseRequest(2, reqPeriod, monitor);
        AbstractResponseRequest processorReq3 = new ResponseRequest(3, reqPeriod, monitor);
        
        processorReq1.installQueueServices(executor, queue);
        processorReq2.installQueueServices(executor, queue);
        processorReq3.installQueueServices(executor, queue);
        
        monitor.attributesAsStream()
            .forEach(entry -> {
                    int reqNumber = (int) entry.get("requestNumber");
                    AbstractResponseRequest processor = reqNumber == 3 ? processorReq3 :
                                                        reqNumber == 2 ? processorReq2 :
                                                                         processorReq1;
                    processor.linkAttribute((AttributeRef) entry.get("attrRef"), (String) entry.get("fieldName"));
                 }
             ); 
        processorReq1.peepRegedAttr();
        
        
        AbstractResponseRequest processor = null;
        SimpleEntry<Integer, String> response;
        
        QueueMessage message;
        
        for(int x=0; x<10;x++) {
            
            System.out.println("Get message from the queue");            
            message = queue.poll(10, TimeUnit.SECONDS);
            assertNotNull(message, "There should be element available in the queue, but queue is still empty!");
            
            int reqNumber = Character.getNumericValue(message.getRequest()[2]);
            System.out.println(String.format("Request#: %d", reqNumber));
            response = responseGenerator.getNext(reqNumber);
            
            System.out.println(String.format("Response generated for request#: %d - %s", response.getKey(), response.getValue()));
            //Add customer number if needed
            switch(response.getKey()) {
                case 1:
                    processor = processorReq1;
                    break;
                case 2:
                    processor = processorReq2;
                    break;                    
                case 3:
                    processor = processorReq3;
                    break;           
            }
            
            System.out.println("Sending response for processing...");
            
            message.accept(response.getValue());            
        }

        int[] reqCounter = responseGenerator.getResponseCounters();
        
        System.out.println(monitor.getSummary(reqCounter[0], reqCounter[1], reqCounter[2]));
        System.out.println(String.format("Monitor update count: %d", (long)monitor.getUpdateCount()));
        System.out.println(String.format("Monitor update hits: %d", (long)monitor.getUpdateHits()));
        assertTrue(monitor.getUpdateCount() == monitor.getUpdateHits(), 
                   String.format("Number of update count (%d) differs from update hits (%d) - %s. ", 
                                 monitor.getUpdateCount(), 
                                 monitor.getUpdateHits(), 
                                 monitor.getUpdateCount() == monitor.getUpdateHits() ? "TRUE" : "FALSE") );    
        assertTrue(scoreBoard.getErrorCounter() == 0, String.format("Scoreboard found %d errors!!", scoreBoard.getErrorCounter()));
    }
    
    
    @Test public void testQueueRef() throws InterruptedException {
               
        int error = 0;
        Integer reqPeriod = 1;
        int count = 0;
        
        
        System.setProperty("MJX_IsolationTestMode", "false");
        LinkedBlockingQueue<QueueMessage> queue = new LinkedBlockingQueue<>();
        ScheduledThreadPoolExecutor executor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1);
        executor.setRemoveOnCancelPolicy(true);
                
        //Create set of 10 attributes for request# 1
        UpdateMonitor monitor = new UpdateMonitor(10, 1);
        
        AbstractResponseRequest processor = new ResponseRequest(1, reqPeriod, monitor);
        processor.installQueueServices(executor, queue);
        //System.out.println(ClassLayout.parseClass(UpdateMonitor.class).toPrintable()); //VM.current().details());
        byte[] request = {'/','#','1'};
        QueueMessage messageIn = new QueueMessage(request, 5, (String resp) -> System.out.println("MessageIN"));
        
        queue.put(messageIn);
        System.out.println(String.format("Message added to the queue, length: %d", messageIn.getResponseLength()));
        
        System.out.println("Let's change original message");
        messageIn.changeLength(10);
                    
        QueueMessage messageOut = queue.poll(10, TimeUnit.SECONDS);
        System.out.println(String.format("Message get out of the queue, length: %d", messageOut.getResponseLength()));
        
        
    }
    
    
}

            
